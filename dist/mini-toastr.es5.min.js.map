{"version":3,"file":"mini-toastr.es5.min.js","sources":["../src/MessageType.ts","../src/MessageClass.ts","../src/mini-toastr-error.class.ts","../src/StyleClass.ts","../src/Animations.ts","../src/mini-toastr.ts"],"sourcesContent":["export type MessageType = 'error' | 'warn' | 'success' | 'info'\n\nexport const ERROR: MessageType = 'error'\nexport const WARN: MessageType = 'warn'\nexport const SUCCESS: MessageType = 'success'\nexport const INFO: MessageType = 'info'","import { ERROR, INFO, SUCCESS, WARN } from './MessageType'\n\n// TODO (S.Panfilov) hardcode\nexport declare type MessageClass = '-error' | '-warn' | '-success' | '-info'\n\n// TODO (S.Panfilov) casting\nexport const ERROR_CLASS: MessageClass = `-${ERROR}` as MessageClass\nexport const WARN_CLASS: MessageClass = `-${WARN}`as MessageClass\nexport const SUCCESS_CLASS: MessageClass = `-${SUCCESS}`as MessageClass\nexport const INFO_CLASS: MessageClass = `-${INFO}`as MessageClass","export class MiniToastrError extends Error {\n  constructor (message: string) {\n    super(message)\n    this.message = message\n    this.name = 'MiniToastrError'\n  }\n}\n","const LIB_NAME = 'mini-toastr'\nconst NOTIFICATION = 'notification'\n\n// TODO (S.Panfilov) hardcode\nexport type StyleClass = 'mini-toastr'\n  | 'mini-toastr__notification'\n  | 'mini-toastr-notification__title'\n  | 'mini-toastr-notification__icon'\n  | 'mini-toastr-notification__message'\n\n// TODO (S.Panfilov) casting\nexport const CONTAINER_CLASS: StyleClass = LIB_NAME as StyleClass\nexport const NOTIFICATION_CLASS: StyleClass = `${LIB_NAME}__${NOTIFICATION}` as StyleClass\nexport const TITLE_CLASS: StyleClass = `${LIB_NAME}-${NOTIFICATION}__title` as StyleClass\nexport const ICON_CLASS: StyleClass = `${LIB_NAME}-${NOTIFICATION}__icon` as StyleClass\nexport const MESSAGE_CLASS: StyleClass = `${LIB_NAME}-${NOTIFICATION}__message` as StyleClass","export function fadeOut (element: HTMLElement, cb?: Function): void {\n  let opacity: number = element.style.opacity ? +element.style.opacity : 0.9\n\n  if (opacity > 0.05) {\n    opacity -= 0.05\n  } else if (opacity <= 0.1) {\n    if (element.parentNode) {\n      element.parentNode.removeChild(element)\n      if (cb) cb()\n    }\n  } else {\n    opacity = 0.9\n  }\n\n  element.style.opacity = opacity.toString()\n  // setTimeout(() => fadeOut.apply((<any>this), [element, cb]), 1000 / 30) // TODO (S.Panfilov) wtf is this here?\n}","import { Config, FullConfig } from './Config'\nimport { MiniToastr } from './MiniToastr'\nimport { ERROR_CLASS, INFO_CLASS, MessageClass, SUCCESS_CLASS, WARN_CLASS } from './MessageClass'\nimport { ERROR, INFO, MessageType, SUCCESS, WARN } from './MessageType'\nimport { MiniToastrError } from './mini-toastr-error.class'\nimport { CONTAINER_CLASS, ICON_CLASS, MESSAGE_CLASS, NOTIFICATION_CLASS, TITLE_CLASS } from './StyleClass'\nimport { fadeOut } from './Animations'\n\nconst DEFAULT_TIMEOUT: number = 3000\nconst DEFAULT_NODE_TYPE: string = 'div'\n\nconst config: FullConfig = {\n  types: { ERROR, WARN, SUCCESS, INFO },\n  animation: fadeOut,\n  timeout: DEFAULT_TIMEOUT,\n  icons: {},\n  appendTarget: document.body,\n  node: makeNode(DEFAULT_NODE_TYPE),\n  allowHtml: false\n}\n\nfunction makeNode (type: string = 'div'): HTMLElement {\n  return document.createElement(type)\n}\n\nfunction createIcon (node: HTMLElement, type: MessageType, config: FullConfig): void {\n  const iconNode = makeNode(config.icons[type].nodeType)\n  const attrs = config.icons[type].attrs\n\n  for (const k in attrs) {\n    if (attrs.hasOwnProperty(k)) {\n      iconNode.setAttribute(k, attrs[k])\n    }\n  }\n\n  node.appendChild(iconNode)\n}\n\nfunction addElem (node: HTMLElement, text: string, className: string, config: FullConfig): void {\n  const elem = makeNode()\n  elem.className = className\n  if (config.allowHtml) {\n    elem.innerHTML = text\n  } else {\n    elem.appendChild(document.createTextNode(text))\n  }\n  node.appendChild(elem)\n}\n\nfunction getTypeClass (type: MessageType): MessageClass {\n  if (type === SUCCESS) return SUCCESS_CLASS\n  if (type === WARN) return WARN_CLASS\n  if (type === ERROR) return ERROR_CLASS\n  if (type === INFO) return INFO_CLASS\n\n  throw new MiniToastrError('Unknown class type. Check mini-toastr\\'s config\\s style section\"')\n}\n\nconst miniToastr: MiniToastr = {\n  config,\n  isInitialised: false,\n  showMessage (message: string, title: string, type: MessageType, timeout: number, cb: Function, overrideConf: Config): MiniToastr {\n    const config = { ...this.config, ...overrideConf } as FullConfig // TODO (S.Panfilov) \"Config\" casting\n\n    const notificationElem = makeNode()\n    notificationElem.className = `${NOTIFICATION_CLASS} ${getTypeClass(type)}`\n    notificationElem.onclick = () => config.animation(notificationElem)\n\n    if (title) addElem(notificationElem, title, TITLE_CLASS, config)\n    if (config.icons[type]) createIcon(notificationElem, type, config)\n    if (message) addElem(notificationElem, message, MESSAGE_CLASS, config)\n\n    config.node.insertBefore(notificationElem, config.node.firstChild)\n    setTimeout(() => config.animation(notificationElem, cb), timeout || config.timeout\n    )\n\n    if (cb) cb()\n    return this\n  },\n  init (aConfig: Config): MiniToastr {\n    this.config = { ...config, ...aConfig } as FullConfig // TODO (S.Panfilov) \"config\" is a kinda global scope and \"Config\" casting\n\n    this.config.node.id = CONTAINER_CLASS\n    this.config.node.className = CONTAINER_CLASS\n    this.config.appendTarget.appendChild(this.config.node)\n\n    // Object.keys(this.config.types).forEach(v => {\n    //     this[this.config.types[v]] = function (message: string, title: string, timeout: number, cb: Function, config: Config) {\n    //       this.showMessage(message, title, this.config.types[v], timeout, cb, config)\n    //       return this\n    //     }.bind(this) // TODO (S.Panfilov) bind?\n    //   }\n    // )\n\n    // TODO (S.Panfilov) check if it's working\n    Object.keys(miniToastr.config.types).forEach(v => {\n        miniToastr[miniToastr.config.types[v]] = function (message: string, title: string, timeout: number, cb: Function, config: Config) {\n          miniToastr.showMessage(message, title, miniToastr.config.types[v], timeout, cb, config)\n          return miniToastr\n        }.bind(this) // TODO (S.Panfilov) bind?\n      }\n    )\n\n    this.isInitialised = true\n\n    return this\n  },\n  setIcon (type: string, nodeType: string = 'i', attrs: any = []): MiniToastr { // TODO (S.Panfilov) attrs is any\n    attrs.class = attrs.class ? attrs.class + ' ' + ICON_CLASS : ICON_CLASS\n\n    this.config.icons[type] = { nodeType, attrs }\n\n    return this\n  }\n}\n\nexport default miniToastr"],"names":["ERROR","WARN","SUCCESS","INFO","ERROR_CLASS","WARN_CLASS","SUCCESS_CLASS","INFO_CLASS","message","_super","_this","name","tslib_1.__extends","Error","LIB_NAME","NOTIFICATION","CONTAINER_CLASS","NOTIFICATION_CLASS","TITLE_CLASS","ICON_CLASS","MESSAGE_CLASS","element","cb","opacity","style","parentNode","removeChild","toString","DEFAULT_TIMEOUT","DEFAULT_NODE_TYPE","config","types","animation","fadeOut","timeout","icons","appendTarget","document","body","node","makeNode","allowHtml","type","createElement","iconNode","nodeType","attrs","k","hasOwnProperty","setAttribute","appendChild","text","className","elem","innerHTML","createTextNode","MiniToastrError","miniToastr","isInitialised","showMessage","title","overrideConf","tslib_1.__assign","this","notificationElem","getTypeClass","onclick","addElem","createIcon","insertBefore","firstChild","setTimeout","init","aConfig","id","Object","keys","forEach","v","bind","setIcon","class"],"mappings":"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"}